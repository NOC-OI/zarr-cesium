"use strict";(self.webpackChunkzarr_cesium_docs=self.webpackChunkzarr_cesium_docs||[]).push([[8137],{8453:(e,a,n)=>{n.d(a,{R:()=>i,x:()=>s});var r=n(6540);const o={},t=r.createContext(o);function i(e){const a=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function s(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(t.Provider,{value:a},e.children)}},9832:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>u,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"api/variables/fragmentShaderSource","title":"fragmentShaderSource","description":"","source":"@site/docs/api/variables/fragmentShaderSource.md","sourceDirName":"api/variables","slug":"/api/variables/fragmentShaderSource","permalink":"/zarr-cesium/docs/docs/api/variables/fragmentShaderSource","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"flagR()","permalink":"/zarr-cesium/docs/docs/api/variables/flagR"},"next":{"title":"gistEarth()","permalink":"/zarr-cesium/docs/docs/api/variables/gistEarth"}}');var o=n(4848),t=n(8453);const i={},s="fragmentShaderSource",u={},l=[];function c(e){const a={code:"code",h1:"h1",header:"header",pre:"pre",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(a.header,{children:(0,o.jsx)(a.h1,{id:"fragmentshadersource",children:"fragmentShaderSource"})}),"\n",(0,o.jsx)(a.pre,{children:(0,o.jsx)(a.code,{className:"language-ts",children:'const fragmentShaderSource: "#version 300 es\\n  precision highp float;\\n\\n  in vec2 v_texCoord;\\n\\n  uniform sampler2D u_dataTexture;\\n  uniform sampler2D u_colorRamp;\\n\\n  uniform float u_min;\\n  uniform float u_max;\\n\\n  uniform float u_noDataMin;\\n  uniform float u_noDataMax;\\n\\n  uniform bool  u_useFillValue;\\n  uniform float u_fillValue;\\n\\n  uniform float u_scaleFactor;\\n  uniform float u_addOffset;\\n\\n  out vec4 fragColor;\\n\\n  void main() {\\n      float raw = texture(u_dataTexture, vec2(v_texCoord.x, 1.0 - v_texCoord.y)).r;\\n\\n      // Convert stored_value \u2192 real_value using CF conventions\\n      float value = raw * u_scaleFactor + u_addOffset;\\n\\n      // Mask invalid values\\n      bool isNaN = (value != value);\\n      bool isNoData = (value < u_noDataMin || value > u_noDataMax);\\n      bool isFill = (u_useFillValue && abs(value - u_fillValue) < 1e-6);\\n\\n      if (isNaN || isNoData || isFill) {\\n          discard;\\n      }\\n\\n      // Normalize\\n      float normalized = clamp((value - u_min) / (u_max - u_min), 0.0, 1.0);\\n\\n      fragColor = texture(u_colorRamp, vec2(normalized, 0.5));\\n  }\\n";\n'})})]})}function d(e={}){const{wrapper:a}={...(0,t.R)(),...e.components};return a?(0,o.jsx)(a,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);